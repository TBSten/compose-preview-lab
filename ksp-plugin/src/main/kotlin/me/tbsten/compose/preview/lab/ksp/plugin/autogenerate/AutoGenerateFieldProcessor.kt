package me.tbsten.compose.preview.lab.ksp.plugin.autogenerate

import com.google.devtools.ksp.processing.Dependencies
import com.google.devtools.ksp.processing.KSPLogger
import com.google.devtools.ksp.processing.Resolver
import com.google.devtools.ksp.symbol.ClassKind
import com.google.devtools.ksp.symbol.KSAnnotation
import com.google.devtools.ksp.symbol.KSClassDeclaration
import com.google.devtools.ksp.processing.CodeGenerator as KspCodeGenerator

private const val AutoGenerateFieldAnnotation =
    "me.tbsten.compose.preview.lab.AutoGenerateField"

/**
 * @AutoGenerateField アノテーションを処理し、Field ファクトリコードを生成する
 */
class AutoGenerateFieldProcessor(private val kspCodeGenerator: KspCodeGenerator, private val logger: KSPLogger,) {
    private val typeClassifier = TypeClassifier()
    private val codeGenerator = CodeGenerator()

    fun process(resolver: Resolver) {
        // @AutoGenerateField が付与されたシンボルを取得
        val annotatedSymbols = resolver.getSymbolsWithAnnotation(AutoGenerateFieldAnnotation)

        // object 宣言のみを対象とする
        val targetObjects = annotatedSymbols
            .filterIsInstance<KSClassDeclaration>()
            .filter { it.classKind == ClassKind.OBJECT }
            .toList()

        if (targetObjects.isEmpty()) return

        // 各 object に対して処理
        targetObjects.forEach { targetObject ->
            processTargetObject(targetObject)
        }
    }

    private fun processTargetObject(targetObject: KSClassDeclaration) {
        val annotations = targetObject.annotations
            .filter {
                it.annotationType.resolve().declaration.qualifiedName?.asString() ==
                    AutoGenerateFieldAnnotation
            }
            .toList()

        if (annotations.isEmpty()) return

        val requests = annotations.mapNotNull { annotation ->
            createFieldGenerationRequest(targetObject, annotation)
        }

        if (requests.isEmpty()) return

        // コード生成
        val generatedCode = codeGenerator.generate(requests)

        // ファイル出力
        val packageName = targetObject.packageName.asString()
        val fileName = "${targetObject.simpleName.asString()}__AutoGeneratedFields"

        val file = kspCodeGenerator.createNewFile(
            dependencies = Dependencies(
                aggregating = false,
                sources = arrayOf(targetObject.containingFile!!),
            ),
            packageName = packageName,
            fileName = fileName,
        )

        file.bufferedWriter().use { writer ->
            writer.write(generatedCode)
        }

        logger.info("Generated $packageName.$fileName")
    }

    private fun createFieldGenerationRequest(
        targetObject: KSClassDeclaration,
        annotation: KSAnnotation,
    ): FieldGenerationRequest? {
        // 型引数を取得
        val typeArgument = annotation.annotationType.element?.typeArguments?.firstOrNull()
        val targetType = typeArgument?.type?.resolve()

        if (targetType == null) {
            logger.error("@AutoGenerateField requires a type argument", annotation)
            return null
        }

        // アノテーションの引数を取得
        val nameArg = annotation.arguments
            .find { it.name?.asString() == "name" }?.value as? String ?: ""
        val autoLabelByTypeName = annotation.arguments
            .find { it.name?.asString() == "autoLabelByTypeName" }?.value as? Boolean ?: false

        // 関数名を決定
        val functionName = if (nameArg.isNotEmpty()) {
            nameArg
        } else {
            targetType.declaration.simpleName.asString().replaceFirstChar { it.lowercase() }
        }

        // 型を分類
        val typeClassification = typeClassifier.classify(targetType)

        return FieldGenerationRequest(
            targetObject = targetObject,
            targetType = targetType,
            typeClassification = typeClassification,
            functionName = functionName,
            autoLabelByTypeName = autoLabelByTypeName,
        )
    }
}
